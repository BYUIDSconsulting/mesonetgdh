[{"path":"https://byuidsconsulting.github.io/weatheR/articles/ODBC.html","id":"step-1-download-the-visual-c-2015-restributable","dir":"Articles","previous_headings":"","what":"Step 1: Download the Visual C++ 2015 Restributable","title":"ODBC","text":"Microsoft Visual C++ 2015 Redistributable software library needed order install Snowflake ODBC driver. First, go download . {width=768px} , asks, make sure download “X64” version: Choose X64 Download Finally, run installer: Run VC++ 2015 Redistributable Installer","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/ODBC.html","id":"step-2-downloading-odbc-software","dir":"Articles","previous_headings":"","what":"Step 2: Downloading ODBC software","title":"ODBC","text":"ODBC way R can connect snowflake database. Windows, can downloaded (instructions). Download snowflake64_odbc-<version>.msi file: Download MSI file Snowflake website run : Run installer","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/ODBC.html","id":"step-3-set-up-odbc","dir":"Articles","previous_headings":"","what":"Step 3: Set up ODBC","title":"ODBC","text":"Go Windows start menu search bar, search “ODBC”.open “ODBC Data Sources (64-bit)”: Search ODBC ODBC window, go “Drivers” tab make sure Snowflake shows : Find Snowflake driver Now, go “System DSN” tab, click “Add” button add Stotz data source: Add new data source Now, set driver configuring data source “SnowflakeDSII”: Select Snowflake driver Now, can set options Snowflake data source can connect Snowflake database. Set Data Source “Stotz”, user “STOTZ_GUEST”, server “ut67101.us-east-2.aws.snowflakecomputing.com”, warehouse “FIREHOSE”. , click “OK”: Configure Snowflake data source Now, back System DSN window, click “OK”. save Stotz data source close ODBC configuration window. Save changes ODBC","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/ODBC.html","id":"step-4-setting-up-username-and-password","dir":"Articles","previous_headings":"","what":"Step 4: Setting up username and password","title":"ODBC","text":"securely store username password, create .Renviron (file extension) file Documents folder already exist: Open file Notepad (create file Notepad exist), set MESONETGDH_UID MESONETGDH_PWD username password Snowflake database: .Renviron credentials","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/ODBC.html","id":"step-5-testing-the-code-in-r","dir":"Articles","previous_headings":"","what":"Step 5: Testing the code in R","title":"ODBC","text":"Finally, can test code R. First, install DBI ODBC packages, allow R connect Snowflake database ODBC: Now, try connecting database: , try using farm production database (return data frame zero rows columns, one can also use dbExecute() instead dbGetQuery() returned table needed): Now, try pulling data database (return data frame 10 rows): screenshot showing querying database R:","code":"install.packages(c(\"DBI\", \"odbc\")) myconn <- DBI::dbConnect(odbc::odbc(), \"Stotz\", uid=Sys.getenv(\"MESONETGDH_UID\"),                          pwd=Sys.getenv(\"MESONETGDH_PWD\")) DBI::dbGetQuery(myconn, \"USE FARM_PROD.FARM__PRODUCTION;\") DBI::dbGetQuery(myconn, \"SELECT FIELD_ID, CROP_NAME FROM FIELD_OPERATIONS LIMIT 10;\")"},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-1-install-the-unixodbc-manager","dir":"Articles","previous_headings":"","what":"Step 1: Install the unixODBC Manager","title":"ODBC for Mac Users","text":"Open terminal enter following commands install manager. brew update brew install unixodbc freetds","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-2-install-the-iodbc-and-odbc-managers","dir":"Articles","previous_headings":"","what":"Step 2: Install the iODBC and ODBC Managers","title":"ODBC for Mac Users","text":"ODBC Manager useful tool configure ODBC DSN. downloaded, open file follow instructions install driver.  iODBC Manager still need installed, despite mentioned earlier. contains files needed properly configure DSNs.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-3-download-the-driver","dir":"Articles","previous_headings":"","what":"Step 3: Download the Driver","title":"ODBC for Mac Users","text":"Download latest version driver Snowflake Client Repository. Download version uses AWS endpoint.      Follow prompts install driver.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-4-specify-the-odbc-manager-path","dir":"Articles","previous_headings":"","what":"Step 4: Specify the ODBC Manager path","title":"ODBC for Mac Users","text":"terminal, use following command open simba.snowflake.ini file: vi /opt/snowflake/snowflakeodbc/lib/universal/simba.snowflake.ini file, instructions uncomment ODBCInstLib used driver manager. driver manager used iODBC. Locate “Darwin Specific ODBCInstLib” file, uncomment line code contains “libodbcinst.dylib”.  Use command :wq save file. throws error, use :wq!.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-5-determine-where-the-default-files-odbc-ini-and-odbcinst-ini-are-located-","dir":"Articles","previous_headings":"","what":"Step 5: Determine where the default files odbc.ini and odbcinst.ini are located.","title":"ODBC for Mac Users","text":"","code":"`odbcinst -j`"},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-6-add-driver","dir":"Articles","previous_headings":"","what":"Step 6: Add Driver","title":"ODBC for Mac Users","text":"Open odbcinst.ini file sudo vi /usr/local/etc/odbcinst.ini prompted password, enter computer’s password access file. Insert following sample text.           [ODBC Drivers]           SnowflakeDSIIDriver=Installed           [SnowflakeDSIIDriver]           APILevel=1           ConnectFunctions=YYY           Description=Snowflake DSII           Driver=/opt/snowflake/snowflakeodbc/lib/universal/libSnowflake.dylib           DriverODBCVer=03.52           SQLLevel=1       end result look like following image.  Save close file using :wq","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-7-add-the-snowflake-dsn","dir":"Articles","previous_headings":"","what":"Step 7: Add the Snowflake DSN","title":"ODBC for Mac Users","text":"Open local odbc.ini file sudo vi /usr/local/etc/odbc.ini Add sample entry file.           [ODBC Data Sources]           SNOWFLAKE_ODBC = SnowflakeDSIIDriver           [SNOWFLAKE_ODBC]           Driver = /opt/snowflake/snowflakeodbc/lib/universal/libSnowflake.dylib           Description = Internal Snowflake           uid = <>           server = <>.snowflakecomputing.com           database = <>           schema = <>           warehouse = <>           role = <>           tracing = 6 Edit sample entry match snowflake database. simplest form, include driver (location driver), name(case ’s ‘SNOWFLAKE_ODBC’), server (url database). options default parameters nothing specified ODBC connect string. Save quit using :wq","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-8verify-the-odbc-dsn-was-created","dir":"Articles","previous_headings":"","what":"Step 8:Verify the ODBC DSN was created","title":"ODBC for Mac Users","text":"output list ODBC DSN","code":"odbcinst -q -s"},{"path":"https://byuidsconsulting.github.io/weatheR/articles/odbc_mac.html","id":"step-9-test-the-snowflake-dsn","dir":"Articles","previous_headings":"","what":"Step 9: Test the Snowflake DSN","title":"ODBC for Mac Users","text":"Run following command, replacing prompt Snowflake DSN’s parameters. isql -v <SNOFLAKE_ODBC_DSN_NAME> <USERNAME> <PASSWORD> result look similar following image:","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"J. Hathway. Author, maintainer. Mars Biziyabal. Author.            api functions, package structure Ellie Anderson. Author.            temperature gdh calulation functions Dawn Galloway. Contributor.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hathway J, Biziyabal M, Anderson E (2022). mesonetgdh: Calculate growing degree hours per day. R package version 0.0.0.9000, https://byuidsconsulting.github.io/weatheR/.","code":"@Manual{,   title = {mesonetgdh: Calculate growing degree hours per day},   author = {J. Hathway and Mars Biziyabal and Ellie Anderson},   year = {2022},   note = {R package version 0.0.0.9000},   url = {https://byuidsconsulting.github.io/weatheR/}, }"},{"path":"https://byuidsconsulting.github.io/weatheR/readme.html","id":"mesonet-gdh-growing-degree-hours","dir":"","previous_headings":"","what":"Mesonet GDH (Growing Degree Hours)","title":"NA","text":"package made possible part due data made available National Weather Service’s Mesonet program written students Brigham Young University - Idaho Data Science program.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/readme.html","id":"installation-instructions","dir":"","previous_headings":"Mesonet GDH (Growing Degree Hours)","what":"Installation Instructions","title":"NA","text":"access Mesonet data, Mesonet GDH package requires key Synoptic data Install package :","code":"devtools::install_github(\"https://github.com/BYUIDSconsulting/mesonetgdh/\")"},{"path":"https://byuidsconsulting.github.io/weatheR/readme.html","id":"notes","dir":"","previous_headings":"Mesonet GDH (Growing Degree Hours)","what":"Notes","title":"NA","text":"temperature growing degree hour calculations Fahrenheit.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/readme.html","id":"more-information","dir":"","previous_headings":"Mesonet GDH (Growing Degree Hours)","what":"More Information","title":"NA","text":"Read Mesonet Data Disclaimer (cite). Learn Mesonet program National Weather Service. Learn Growing Degree Days (GDD).","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Growing Degree Hours — calc_gdh","title":"Calculate Growing Degree Hours — calc_gdh","text":"Calculate Growing Degree Hours","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Growing Degree Hours — calc_gdh","text":"","code":"calc_gdh(data, field = NULL)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Growing Degree Hours — calc_gdh","text":"data dataframe output 'combine_df' function","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Growing Degree Hours — calc_gdh","text":"growing degree hours dataframe provided","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Growing Degree Hours — calc_gdh","text":"","code":"data = temp_df #> Error in eval(expr, envir, enclos): object 'temp_df' not found growing_degrees <- calc_gdh(data) #> Error in data %>% group_by(FIELD_ID, CROP_NAME, CROP_SEASON, Date, Hour) %>%     filter(Date >= seeding_date & Date <= harvest_date) %>% summarize(seeding_date = seeding_date,     harvest_date = harvest_date, gdh = temp_combined_avg - Base_Fahrenheit,     gdh = case_when(gdh < 0 ~ 0, temp_combined_avg > Upper_Fahrenheit ~         Upper_Fahrenheit - Base_Fahrenheit, TRUE ~ gdh), ) %>%     rename(GDH_DATE = Date): could not find function \"%>%\" print(growing_degrees) #> Error in print(growing_degrees): object 'growing_degrees' not found"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_hourly_temp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate hourly temperature — calc_hourly_temp","title":"Calculate hourly temperature — calc_hourly_temp","text":"Calculate hourly temperature","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_hourly_temp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate hourly temperature — calc_hourly_temp","text":"","code":"calc_hourly_temp(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_hourly_temp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate hourly temperature — calc_hourly_temp","text":"data dataframe contains temp data. Cols named 'date_time', 'air_temp_set_1'","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_hourly_temp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate hourly temperature — calc_hourly_temp","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x558e45e840f8> #> <environment: namespace:utils> p <- calc_hourly_temp(data) #> Error in data %>% group_by(FIELD_ID, CROP_SEASON) %>% filter(date_time >=     seeding_date & date_time <= harvest_date) %>% ungroup() %>%     mutate(date_time = lubridate::ymd_hms(date_time), Hour = lubridate::hour(date_time),         Date = lubridate::date(date_time)) %>% group_by(FIELD_ID,     CROP_SEASON, station_id, Date, Hour) %>% mutate(temp_avg = mean(air_temp_set_1,     na.rm = TRUE)) %>% ungroup() %>% distinct(across(c(station_id,     Date, Hour)), .keep_all = TRUE) %>% group_by(FIELD_ID, CROP_SEASON) %>%     complete(station_id, Date, Hour) %>% as.data.frame() %>%     ungroup() %>% select(-c(air_temp_set_1, date_time)): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/combine_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Temporary Dataframe to Calculate GDHs — combine_df","title":"Create Temporary Dataframe to Calculate GDHs — combine_df","text":"Create Temporary Dataframe Calculate GDHs","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/combine_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Temporary Dataframe to Calculate GDHs — combine_df","text":"","code":"combine_df(temp_data, database_data, gdh_data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/combine_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Temporary Dataframe to Calculate GDHs — combine_df","text":"temp_data field_weather_data 'create_field_weather_data' database_data field information, including crop seeding date gdh_data information needed calculate GDHs, including base upper temps","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/create_field_weather_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of temperature aggregations — create_field_weather_data","title":"Summary of temperature aggregations — create_field_weather_data","text":"Summary temperature aggregations","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/create_field_weather_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of temperature aggregations — create_field_weather_data","text":"","code":"create_field_weather_data(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/create_field_weather_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of temperature aggregations — create_field_weather_data","text":"data dataframe contains temperatures station. Temp column named \"temp_avg","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/create_field_weather_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of temperature aggregations — create_field_weather_data","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x558e45e840f8> #> <environment: namespace:utils> p <- elev_change(data) #> Error in data %>% group_by(FIELD_ID, station_id) %>% summarize(elev_dif = field_elev -     station_elev) %>% unique(): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_crops.html","id":null,"dir":"Reference","previous_headings":"","what":"Request crop data (seed_harvest_wide) from Snowflake within a certain season range — download_crops","title":"Request crop data (seed_harvest_wide) from Snowflake within a certain season range — download_crops","text":"Request crop data (seed_harvest_wide) Snowflake within certain season range","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_crops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request crop data (seed_harvest_wide) from Snowflake within a certain season range — download_crops","text":"","code":"download_crops(conn, gdd_info_formatted, min_year = NA, max_year = NA)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_crops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request crop data (seed_harvest_wide) from Snowflake within a certain season range — download_crops","text":"conn connection Snowflake database min_year Minimum crop season year pull . Defaults NA (pull years) max_year Maximum crop season year pull . Defaults NA (pull years)","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_crops.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Request crop data (seed_harvest_wide) from Snowflake within a certain season range — download_crops","text":"seed_harvest_df data frame.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_crops.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Request crop data (seed_harvest_wide) from Snowflake within a certain season range — download_crops","text":"","code":"seed_harvest_wide <- download_crops(myconn, min_year=2020, max_year=2022) #> Error in loadNamespace(x): there is no package called ‘gtools’"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_fields.html","id":null,"dir":"Reference","previous_headings":"","what":"Request fields data (all_fields1) from Snowflake — download_fields","title":"Request fields data (all_fields1) from Snowflake — download_fields","text":"Request fields data (all_fields1) Snowflake","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_fields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request fields data (all_fields1) from Snowflake — download_fields","text":"","code":"download_fields(conn, min_year = NA, max_year = NA)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_fields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request fields data (all_fields1) from Snowflake — download_fields","text":"conn connection Snowflake database","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_fields.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Request fields data (all_fields1) from Snowflake — download_fields","text":"all_fields1 data frame.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/download_fields.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Request fields data (all_fields1) from Snowflake — download_fields","text":"","code":"all_fields1 <- download_crops(myconn) %>% filter(state %in% c('AZ','ID','UT')) #> Error in download_crops(myconn) %>% filter(state %in% c(\"AZ\", \"ID\", \"UT\")): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/elev_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate elevation difference — elev_change","title":"Calculate elevation difference — elev_change","text":"Calculate elevation difference","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/elev_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate elevation difference — elev_change","text":"","code":"elev_change(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/elev_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate elevation difference — elev_change","text":"data dataframe contains elevations. Columns named \"field_elev\" \"station_elev\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/elev_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate elevation difference — elev_change","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x558e45e840f8> #> <environment: namespace:utils> p <- elev_change(data) #> Error in data %>% group_by(FIELD_ID, station_id) %>% summarize(elev_dif = field_elev -     station_elev) %>% unique(): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/find_closest_stations.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the closest stations — find_closest_stations","title":"Find the closest stations — find_closest_stations","text":"Find closest stations","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/find_closest_stations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the closest stations — find_closest_stations","text":"","code":"find_closest_stations(field_df, stations_df, radius)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/find_closest_stations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the closest stations — find_closest_stations","text":"field_df fields dataset. stations_df dataset includes active stations derived pull_active_stations() function. radius set maximum distance station away field.","code":""},{"path":[]},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_all_fields.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all fields from the Snowflake database — get_all_fields","title":"Get all fields from the Snowflake database — get_all_fields","text":"Get fields Snowflake database","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_all_fields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all fields from the Snowflake database — get_all_fields","text":"","code":"get_all_fields(myconn)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_all_fields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all fields from the Snowflake database — get_all_fields","text":"myconn connection Snowflake database","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_all_fields.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get all fields from the Snowflake database — get_all_fields","text":"","code":"all_fields1 <- get_all_fields(myconn) #> Error in DBI::dbGetQuery(myconn, fields_query) %>% rename(lat = LAT, lon = LON) %>%     distinct(FIELD_ID, .keep_all = TRUE): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_elev.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Elevations — get_elev","title":"Get Elevations — get_elev","text":"Get Elevations","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_elev.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Elevations — get_elev","text":"","code":"get_elev(df, conn = NULL)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_elev.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Elevations — get_elev","text":"df dataframe output 'all_fields' function","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_elev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Elevations — get_elev","text":"","code":"df = makeaneexample #> Error in eval(expr, envir, enclos): object 'makeaneexample' not found get_elev(df) #> Error in df$row_num <- seq.int(nrow(df)): object of type 'closure' is not subsettable"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_latest_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Get latest date with GDHs from the Snowflake database — get_latest_date","title":"Get latest date with GDHs from the Snowflake database — get_latest_date","text":"Get latest date GDHs Snowflake database","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_latest_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get latest date with GDHs from the Snowflake database — get_latest_date","text":"","code":"get_latest_date(myconn)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_latest_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get latest date with GDHs from the Snowflake database — get_latest_date","text":"myconn connection Snowflake database","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_latest_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get latest date with GDHs from the Snowflake database — get_latest_date","text":"","code":"latest_date <- get_latest_date(myconn) #> Error in DBI::dbGetQuery(myconn, \"SELECT * FROM GDH_BYUI_DEV ORDER BY GDH_DATE DESC LIMIT 1;\") %>%     pull(GDH_DATE): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_seed_harvest_wide.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the wide seed harvest dataframe (based on field crops data) from the Snowflake database — get_seed_harvest_wide","title":"Get the wide seed harvest dataframe (based on field crops data) from the Snowflake database — get_seed_harvest_wide","text":"Reformat date wide format data","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_seed_harvest_wide.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the wide seed harvest dataframe (based on field crops data) from the Snowflake database — get_seed_harvest_wide","text":"","code":"get_seed_harvest_wide(myconn, gdd_info_formatted)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_seed_harvest_wide.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the wide seed harvest dataframe (based on field crops data) from the Snowflake database — get_seed_harvest_wide","text":"myconn connection Snowflake database gdd_info_formatted Growing Degree Day temperature threshold data","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_seed_harvest_wide.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the wide seed harvest dataframe (based on field crops data) from the Snowflake database — get_seed_harvest_wide","text":"","code":"seed_harvest_df <- get_seed_harvest(myconn) #> Error in get_seed_harvest(myconn): could not find function \"get_seed_harvest\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Get state abbreviations — get_state","title":"Get state abbreviations — get_state","text":"Get state abbreviations","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get state abbreviations — get_state","text":"","code":"get_state(df)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get state abbreviations — get_state","text":"df dataframe includes coordinate columns. Make sure rename columns 'lat', 'lon'","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get state abbreviations — get_state","text":"","code":"df  #> function (x, df1, df2, ncp, log = FALSE)  #> { #>     if (missing(ncp))  #>         .Call(C_df, x, df1, df2, log) #>     else .Call(C_dnf, x, df1, df2, ncp, log) #> } #> <bytecode: 0x558e4588fc30> #> <environment: namespace:stats> df$state <- get_state(df) #> Warning message: #> Missing lat, lon columns.  #> Please rename coordinate columns to \"lat\", \"lon\" #> Error in df$state <- get_state(df): object of type 'closure' is not subsettable"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lat_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate latitudinal distance — lat_dist","title":"Calculate latitudinal distance — lat_dist","text":"Calculate latitudinal distance","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lat_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate latitudinal distance — lat_dist","text":"","code":"lat_dist(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lat_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate latitudinal distance — lat_dist","text":"data dataframe contains latitude. Column named \"lat\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lat_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate latitudinal distance — lat_dist","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x558e45e840f8> #> <environment: namespace:utils> p <- lat_dist(data) #> Loading required package: geosphere #> Error in data$dummy <- 0: object of type 'closure' is not subsettable"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lon_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate longitudinal distance — lon_dist","title":"Calculate longitudinal distance — lon_dist","text":"Calculate longitudinal distance","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lon_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate longitudinal distance — lon_dist","text":"","code":"lon_dist(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lon_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate longitudinal distance — lon_dist","text":"data dataframe contains latitude. Column named \"lon\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lon_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate longitudinal distance — lon_dist","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x558e45e840f8> #> <environment: namespace:utils> p <- lon_dist(data) #> Error in data$dummy <- 0: object of type 'closure' is not subsettable"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_active_stations.html","id":null,"dir":"Reference","previous_headings":"","what":"Pull active stations from MesoWest API — pull_active_stations","title":"Pull active stations from MesoWest API — pull_active_stations","text":"Pull active stations MesoWest API","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_active_stations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pull active stations from MesoWest API — pull_active_stations","text":"","code":"pull_active_stations(df, key)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_active_stations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pull active stations from MesoWest API — pull_active_stations","text":"df 'fields' dataset, including FIELD id,lat,lon,elevation,state, CROP name,season, seeding harvest dates key API key MesoWest","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_active_stations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pull active stations from MesoWest API — pull_active_stations","text":"","code":"p <- pull_active_stations(df, key) #> Error in paste0(base_url, \"/auth?apikey=\", key): object 'key' not found"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp.html","id":null,"dir":"Reference","previous_headings":"","what":"Request the temperature data from MesoWest — pull_temp","title":"Request the temperature data from MesoWest — pull_temp","text":"Request temperature data MesoWest","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request the temperature data from MesoWest — pull_temp","text":"","code":"pull_temp(df)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request the temperature data from MesoWest — pull_temp","text":"df fields_stations dataset derived find_closest_station() function.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Request the temperature data from MesoWest — pull_temp","text":"","code":"p <- pull_temp(df) #> Error in df %>% select(station_id, harvest_date, seeding_date): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Request the temperature data from MesoWest, but fast — pull_temp_all","title":"Request the temperature data from MesoWest, but fast — pull_temp_all","text":"Request temperature data MesoWest, fast","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request the temperature data from MesoWest, but fast — pull_temp_all","text":"","code":"pull_temp_all(df, min_date = NA, max_date = NA)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request the temperature data from MesoWest, but fast — pull_temp_all","text":"df fields_stations dataset derived find_closest_station() function.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Request the temperature data from MesoWest, but fast — pull_temp_all","text":"","code":"p <- pull_temp_all(df) #> Error in df %>% select(station_id, harvest_date, seeding_date): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_full.html","id":null,"dir":"Reference","previous_headings":"","what":"Request the hourly temperature data from MesoWest and process it — pull_temp_full","title":"Request the hourly temperature data from MesoWest and process it — pull_temp_full","text":"Request hourly temperature data MesoWest process ","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_full.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request the hourly temperature data from MesoWest and process it — pull_temp_full","text":"","code":"pull_temp_full(fields_stations)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_full.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request the hourly temperature data from MesoWest and process it — pull_temp_full","text":"fields_stations fields_stations dataset derived find_closest_station() function.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_full.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Request the hourly temperature data from MesoWest and process it — pull_temp_full","text":"","code":"station_temp_data <- pull_temp_full(fields_stations) #> Error in fields_stations %>% group_by(station_id, CROP_SEASON) %>% summarise(seeding_date = min(seeding_date),     harvest_date = max(harvest_date)): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/push_gdh.html","id":null,"dir":"Reference","previous_headings":"","what":"Push GDH data to Snowflake. — push_gdh","title":"Push GDH data to Snowflake. — push_gdh","text":"Push GDH data Snowflake.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/push_gdh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Push GDH data to Snowflake. — push_gdh","text":"","code":"push_gdh(myconn, table = \"GDH_BYUI_DEV\", growing_degree_units)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/push_gdh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Push GDH data to Snowflake. — push_gdh","text":"myconn connection Snowflake database. table table push . growing_degree_units GDH data push.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/remove_duplicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove duplicate rows from a Snowflake table — remove_duplicates","title":"Remove duplicate rows from a Snowflake table — remove_duplicates","text":"Remove duplicate rows Snowflake table","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/remove_duplicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove duplicate rows from a Snowflake table — remove_duplicates","text":"","code":"remove_duplicates(myconn, table)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/remove_duplicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove duplicate rows from a Snowflake table — remove_duplicates","text":"myconn connection Snowflake database table table remove duplicates ","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/remove_duplicates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove duplicate rows from a Snowflake table — remove_duplicates","text":"","code":"remove_duplicates(table) #> Error in sprintf(\"CREATE TABLE new_table LIKE %s COPY GRANTS;\", table): argument \"table\" is missing, with no default"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/seed_harvest_clean.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter/restructure seeding and harvest data — seed_harvest_clean","title":"Filter/restructure seeding and harvest data — seed_harvest_clean","text":"Filter/restructure seeding harvest data","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/seed_harvest_clean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter/restructure seeding and harvest data — seed_harvest_clean","text":"","code":"seed_harvest_clean(seed_harvest_data, method = NULL)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/seed_harvest_clean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter/restructure seeding and harvest data — seed_harvest_clean","text":"seed_harvest_data dataset containing crop seeding harvest dates fields pulled database. method choose 'current' 'historic'. 'current' include current year crop season. 'historic' exclude current year crop season.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/seed_harvest_clean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter/restructure seeding and harvest data — seed_harvest_clean","text":"","code":"p <- seed_harvest_clean(seed_harvest_data, method = current) #> Error in seed_harvest_clean(seed_harvest_data, method = current): could not find function \"seed_harvest_clean\" p <- seed_harvest_clean(seed_harvest_data, method = historic) #> Error in seed_harvest_clean(seed_harvest_data, method = historic): could not find function \"seed_harvest_clean\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/total_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distance — total_dist","title":"Calculate distance — total_dist","text":"Calculate distance","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/total_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distance — total_dist","text":"","code":"total_dist(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/total_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distance — total_dist","text":"data dataframe contains latitude longitude. Columns named \"lat\" \"lon\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/total_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate distance — total_dist","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x558e45e840f8> #> <environment: namespace:utils> p <- total_dist(data) #> Error in data %>% group_by(FIELD_ID, station_id) %>% summarize(total_dist = distHaversine(matrix(c(field_lon,     field_lat), ncol = 2), matrix(c(station_lon, station_lat),     ncol = 2))) %>% unique(): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate weights according to elevation — weighted","title":"Calculate weights according to elevation — weighted","text":"Calculate weights according elevation","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate weights according to elevation — weighted","text":"","code":"weighted(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate weights according to elevation — weighted","text":"data dataframe contains elevations. Columns named \"FIELD_ID\" \"station_id\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate weights according to elevation — weighted","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x558e45e840f8> #> <environment: namespace:utils> p <- weighted(data) #> Error in elev_change(data) %>% mutate(adjusted_wt = -elev_dif/1000 * 3.5) %>%     distinct(across(c(\"FIELD_ID\", \"station_id\")), .keep_all = TRUE): could not find function \"%>%\""}]
