[{"path":"https://byuidsconsulting.github.io/weatheR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"J. Hathway. Author, maintainer. Mars Biziyabal. Author.            api functions, package structure Ellie Anderson. Author.            temperature gdh calulation functions Dawn Galloway. Contributor.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hathway J, Biziyabal M, Anderson E (2022). mesonetgdh: Calculate growing degree hours per day. R package version 0.0.0.9000, https://byuidsconsulting.github.io/weatheR/.","code":"@Manual{,   title = {mesonetgdh: Calculate growing degree hours per day},   author = {J. Hathway and Mars Biziyabal and Ellie Anderson},   year = {2022},   note = {R package version 0.0.0.9000},   url = {https://byuidsconsulting.github.io/weatheR/}, }"},{"path":"https://byuidsconsulting.github.io/weatheR/readme.html","id":"mesonet-gdh-growing-degree-hours","dir":"","previous_headings":"","what":"Mesonet GDH (Growing Degree Hours)","title":"NA","text":"package made possible part due data made available National Weather Service’s Mesonet program written students Brigham Young University - Idaho Data Science program.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/readme.html","id":"installation-instructions","dir":"","previous_headings":"Mesonet GDH (Growing Degree Hours)","what":"Installation Instructions","title":"NA","text":"access Mesonet data, Mesonet GDH package requires key Synoptic data Install package :","code":"devtools::install_github(\"https://github.com/BYUIDSconsulting/mesonetgdh/\")"},{"path":"https://byuidsconsulting.github.io/weatheR/readme.html","id":"notes","dir":"","previous_headings":"Mesonet GDH (Growing Degree Hours)","what":"Notes","title":"NA","text":"temperature growing degree hour calculations Fahrenheit.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/readme.html","id":"more-information","dir":"","previous_headings":"Mesonet GDH (Growing Degree Hours)","what":"More Information","title":"NA","text":"Read Mesonet Data Disclaimer (cite). Learn Mesonet program National Weather Service. Learn Growing Degree Days (GDD).","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Growing Degree Hours — calc_gdh","title":"Calculate Growing Degree Hours — calc_gdh","text":"Calculate Growing Degree Hours","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Growing Degree Hours — calc_gdh","text":"","code":"calc_gdh(data, field = NULL)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Growing Degree Hours — calc_gdh","text":"data dataframe output 'combine_df' function","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Growing Degree Hours — calc_gdh","text":"growing degree hours dataframe provided","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_gdh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Growing Degree Hours — calc_gdh","text":"","code":"data = temp_df #> Error in eval(expr, envir, enclos): object 'temp_df' not found growing_degrees <- calc_gdh(data) #> Error in data %>% group_by(FIELD_ID, CROP_NAME, CROP_SEASON, Date) %>%     filter(Date >= seeding_date & Date <= harvest_date) %>% summarize(seeding_date = seeding_date,     harvest_date = harvest_date, gdh = temp_combined_avg - Base_Fahrenheit,     gdh = case_when(gdh < 0 ~ 0, temp_combined_avg > Upper_Fahrenheit ~         Upper_Fahrenheit - Base_Fahrenheit, TRUE ~ gdh)): could not find function \"%>%\" print(growing_degrees) #> Error in print(growing_degrees): object 'growing_degrees' not found"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_hourly_temp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate hourly temperature — calc_hourly_temp","title":"Calculate hourly temperature — calc_hourly_temp","text":"Calculate hourly temperature","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_hourly_temp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate hourly temperature — calc_hourly_temp","text":"","code":"calc_hourly_temp(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_hourly_temp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate hourly temperature — calc_hourly_temp","text":"data dataframe contains temp data. Cols named 'date_time', 'air_temp_set_1'","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/calc_hourly_temp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate hourly temperature — calc_hourly_temp","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x563a063d2ad8> #> <environment: namespace:utils> p <- calc_hourly_temp(data) #> Error in data %>% group_by(FIELD_ID, CROP_SEASON) %>% filter(date_time >=     seeding_date & date_time <= harvest_date) %>% ungroup() %>%     mutate(date_time = lubridate::ymd_hms(date_time), Hour = lubridate::hour(date_time),         Date = lubridate::date(date_time)) %>% group_by(FIELD_ID,     CROP_SEASON, station_id, Date, Hour) %>% mutate(temp_avg = mean(air_temp_set_1,     na.rm = TRUE)) %>% ungroup() %>% distinct(across(c(station_id,     Date, Hour)), .keep_all = TRUE) %>% group_by(FIELD_ID, CROP_SEASON) %>%     complete(station_id, Date, Hour) %>% as.data.frame() %>%     ungroup() %>% select(-c(air_temp_set_1, date_time)): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/combine_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Temporary Dataframe to Calculate GDHs — combine_df","title":"Create Temporary Dataframe to Calculate GDHs — combine_df","text":"Create Temporary Dataframe Calculate GDHs","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/combine_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Temporary Dataframe to Calculate GDHs — combine_df","text":"","code":"combine_df(temp_data, database_data, gdh_data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/combine_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Temporary Dataframe to Calculate GDHs — combine_df","text":"temp_data field_weather_data 'create_field_weather_data' database_data field information, including crop seeding date gdh_data information needed calculate GDHs, including base upper temps","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/create_field_weather_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of temperature aggregations — create_field_weather_data","title":"Summary of temperature aggregations — create_field_weather_data","text":"Summary temperature aggregations","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/create_field_weather_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of temperature aggregations — create_field_weather_data","text":"","code":"create_field_weather_data(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/create_field_weather_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of temperature aggregations — create_field_weather_data","text":"data dataframe contains temperatures station. Temp column named \"temp_avg","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/create_field_weather_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of temperature aggregations — create_field_weather_data","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x563a063d2ad8> #> <environment: namespace:utils> p <- elev_change(data) #> Error in data %>% group_by(FIELD_ID, station_id) %>% summarize(elev_dif = field_elev -     station_elev) %>% unique(): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/elev_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate elevation difference — elev_change","title":"Calculate elevation difference — elev_change","text":"Calculate elevation difference","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/elev_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate elevation difference — elev_change","text":"","code":"elev_change(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/elev_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate elevation difference — elev_change","text":"data dataframe contains elevations. Columns named \"field_elev\" \"station_elev\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/elev_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate elevation difference — elev_change","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x563a063d2ad8> #> <environment: namespace:utils> p <- elev_change(data) #> Error in data %>% group_by(FIELD_ID, station_id) %>% summarize(elev_dif = field_elev -     station_elev) %>% unique(): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/find_closest_stations.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the closest stations — find_closest_stations","title":"Find the closest stations — find_closest_stations","text":"Find closest stations","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/find_closest_stations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the closest stations — find_closest_stations","text":"","code":"find_closest_stations(field_df, stations_df, radius)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/find_closest_stations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the closest stations — find_closest_stations","text":"field_df fields dataset. stations_df dataset includes active stations derived pull_active_stations() function. radius set maximum distance station away field.","code":""},{"path":[]},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_elev.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Elevations — get_elev","title":"Get Elevations — get_elev","text":"Get Elevations","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_elev.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Elevations — get_elev","text":"","code":"get_elev(df)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_elev.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Elevations — get_elev","text":"df dataframe output 'all_fields' function","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_elev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Elevations — get_elev","text":"","code":"df = makeaneexample #> Error in eval(expr, envir, enclos): object 'makeaneexample' not found get_elev(df) #> Error: object of type 'closure' is not subsettable"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Get state abbreviations — get_state","title":"Get state abbreviations — get_state","text":"Get state abbreviations","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get state abbreviations — get_state","text":"","code":"get_state(df)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get state abbreviations — get_state","text":"df dataframe includes coordinate columns. Make sure rename columns 'lat', 'lon'","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/get_state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get state abbreviations — get_state","text":"","code":"df  #> function (x, df1, df2, ncp, log = FALSE)  #> { #>     if (missing(ncp))  #>         .Call(C_df, x, df1, df2, log) #>     else .Call(C_dnf, x, df1, df2, ncp, log) #> } #> <bytecode: 0x563a07cf9ab0> #> <environment: namespace:stats> df$state <- get_state(df) #> Warning message: #> Missing lat, lon columns.  #> Please rename coordinate columns to \"lat\", \"lon\" #> Error in df$state <- get_state(df): object of type 'closure' is not subsettable"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lat_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate latitudinal distance — lat_dist","title":"Calculate latitudinal distance — lat_dist","text":"Calculate latitudinal distance","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lat_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate latitudinal distance — lat_dist","text":"","code":"lat_dist(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lat_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate latitudinal distance — lat_dist","text":"data dataframe contains latitude. Column named \"lat\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lat_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate latitudinal distance — lat_dist","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x563a063d2ad8> #> <environment: namespace:utils> p <- lat_dist(data) #> Loading required package: geosphere #> Error in data$dummy <- 0: object of type 'closure' is not subsettable"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lon_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate longitudinal distance — lon_dist","title":"Calculate longitudinal distance — lon_dist","text":"Calculate longitudinal distance","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lon_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate longitudinal distance — lon_dist","text":"","code":"lon_dist(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lon_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate longitudinal distance — lon_dist","text":"data dataframe contains latitude. Column named \"lon\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/lon_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate longitudinal distance — lon_dist","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x563a063d2ad8> #> <environment: namespace:utils> p <- lon_dist(data) #> Error in data$dummy <- 0: object of type 'closure' is not subsettable"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_active_stations.html","id":null,"dir":"Reference","previous_headings":"","what":"Pull active stations from MesoWest API — pull_active_stations","title":"Pull active stations from MesoWest API — pull_active_stations","text":"Pull active stations MesoWest API","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_active_stations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pull active stations from MesoWest API — pull_active_stations","text":"","code":"pull_active_stations(df, key)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_active_stations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pull active stations from MesoWest API — pull_active_stations","text":"df 'fields' dataset, including FIELD id,lat,lon,elevation,state, CROP name,season, seeding harvest dates key API key MesoWest","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_active_stations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pull active stations from MesoWest API — pull_active_stations","text":"","code":"p <- pull_active_stations(df, key) #> Error in pull_active_stations(df, key): could not find function \"pull_active_stations\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp.html","id":null,"dir":"Reference","previous_headings":"","what":"Request the temperature data from MesoWest — pull_temp","title":"Request the temperature data from MesoWest — pull_temp","text":"Request temperature data MesoWest","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request the temperature data from MesoWest — pull_temp","text":"","code":"pull_temp(df)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request the temperature data from MesoWest — pull_temp","text":"df fields_stations dataset derived find_closest_station() function.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Request the temperature data from MesoWest — pull_temp","text":"","code":"p <- pull_temp(df) #> Error in df %>% select(station_id, harvest_date, seeding_date): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_all.html","id":null,"dir":"Reference","previous_headings":"","what":"Request the temperature data from MesoWest, but fast — pull_temp_all","title":"Request the temperature data from MesoWest, but fast — pull_temp_all","text":"Request temperature data MesoWest, fast","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Request the temperature data from MesoWest, but fast — pull_temp_all","text":"","code":"pull_temp_all(df)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Request the temperature data from MesoWest, but fast — pull_temp_all","text":"df fields_stations dataset derived find_closest_station() function.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/pull_temp_all.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Request the temperature data from MesoWest, but fast — pull_temp_all","text":"","code":"p <- pull_temp_all(df) #> Error in df %>% select(station_id, harvest_date, seeding_date): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/seed_harvest_clean.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter/restructure seeding and harvest data — seed_harvest_clean","title":"Filter/restructure seeding and harvest data — seed_harvest_clean","text":"Filter/restructure seeding harvest data","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/seed_harvest_clean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter/restructure seeding and harvest data — seed_harvest_clean","text":"","code":"seed_harvest_clean(seed_harvest_data, method = NULL)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/seed_harvest_clean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter/restructure seeding and harvest data — seed_harvest_clean","text":"seed_harvest_data dataset containing crop seeding harvest dates fields pulled database. method choose 'current' 'historic'. 'current' include current year crop season. 'historic' exclude current year crop season.","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/seed_harvest_clean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter/restructure seeding and harvest data — seed_harvest_clean","text":"","code":"p <- seed_harvest_clean(seed_harvest_data, method = current) #> Error in seed_harvest_clean(seed_harvest_data, method = current): could not find function \"seed_harvest_clean\" p <- seed_harvest_clean(seed_harvest_data, method = historic) #> Error in seed_harvest_clean(seed_harvest_data, method = historic): could not find function \"seed_harvest_clean\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/total_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate distance — total_dist","title":"Calculate distance — total_dist","text":"Calculate distance","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/total_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate distance — total_dist","text":"","code":"total_dist(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/total_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate distance — total_dist","text":"data dataframe contains latitude longitude. Columns named \"lat\" \"lon\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/total_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate distance — total_dist","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x563a063d2ad8> #> <environment: namespace:utils> p <- total_dist(data) #> Error in data %>% group_by(FIELD_ID, station_id) %>% summarize(total_dist = distHaversine(matrix(c(field_lon,     field_lat), ncol = 2), matrix(c(station_lon, station_lat),     ncol = 2))) %>% unique(): could not find function \"%>%\""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate weights according to elevation — weighted","title":"Calculate weights according to elevation — weighted","text":"Calculate weights according elevation","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate weights according to elevation — weighted","text":"","code":"weighted(data)"},{"path":"https://byuidsconsulting.github.io/weatheR/reference/weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate weights according to elevation — weighted","text":"data dataframe contains elevations. Columns named \"FIELD_ID\" \"station_id\"","code":""},{"path":"https://byuidsconsulting.github.io/weatheR/reference/weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate weights according to elevation — weighted","text":"","code":"data  #> function (..., list = character(), package = NULL, lib.loc = NULL,  #>     verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)  #> { #>     fileExt <- function(x) { #>         db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x) #>         ans <- sub(\".*\\\\.\", \"\", x) #>         ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\",  #>             x[db]) #>         ans #>     } #>     my_read_table <- function(...) { #>         lcc <- Sys.getlocale(\"LC_COLLATE\") #>         on.exit(Sys.setlocale(\"LC_COLLATE\", lcc)) #>         Sys.setlocale(\"LC_COLLATE\", \"C\") #>         read.table(...) #>     } #>     stopifnot(is.character(list)) #>     names <- c(as.character(substitute(list(...))[-1L]), list) #>     if (!is.null(package)) { #>         if (!is.character(package))  #>             stop(\"'package' must be a character vector or NULL\") #>     } #>     paths <- find.package(package, lib.loc, verbose = verbose) #>     if (is.null(lib.loc))  #>         paths <- c(path.package(package, TRUE), if (!length(package)) getwd(),  #>             paths) #>     paths <- unique(normalizePath(paths[file.exists(paths)])) #>     paths <- paths[dir.exists(file.path(paths, \"data\"))] #>     dataExts <- tools:::.make_file_exts(\"data\") #>     if (length(names) == 0L) { #>         db <- matrix(character(), nrow = 0L, ncol = 4L) #>         for (path in paths) { #>             entries <- NULL #>             packageName <- if (file_test(\"-f\", file.path(path,  #>                 \"DESCRIPTION\")))  #>                 basename(path) #>             else \".\" #>             if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\",  #>                 \"data.rds\"))) { #>                 entries <- readRDS(INDEX) #>             } #>             else { #>                 dataDir <- file.path(path, \"data\") #>                 entries <- tools::list_files_with_type(dataDir,  #>                   \"data\") #>                 if (length(entries)) { #>                   entries <- unique(tools::file_path_sans_ext(basename(entries))) #>                   entries <- cbind(entries, \"\") #>                 } #>             } #>             if (NROW(entries)) { #>                 if (is.matrix(entries) && ncol(entries) == 2L)  #>                   db <- rbind(db, cbind(packageName, dirname(path),  #>                     entries)) #>                 else warning(gettextf(\"data index for package %s is invalid and will be ignored\",  #>                   sQuote(packageName)), domain = NA, call. = FALSE) #>             } #>         } #>         colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\") #>         footer <- if (missing(package))  #>             paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")),  #>                 \"\\n\", \"to list the data sets in all *available* packages.\") #>         else NULL #>         y <- list(title = \"Data sets\", header = NULL, results = db,  #>             footer = footer) #>         class(y) <- \"packageIQR\" #>         return(y) #>     } #>     paths <- file.path(paths, \"data\") #>     for (name in names) { #>         found <- FALSE #>         for (p in paths) { #>             tmp_env <- if (overwrite)  #>                 envir #>             else new.env() #>             if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) { #>                 rds <- readRDS(file.path(p, \"Rdata.rds\")) #>                 if (name %in% names(rds)) { #>                   found <- TRUE #>                   if (verbose)  #>                     message(sprintf(\"name=%s:\\t found in Rdata.rds\",  #>                       name), domain = NA) #>                   thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p) #>                   thispkg <- sub(\"_.*$\", \"\", thispkg) #>                   thispkg <- paste0(\"package:\", thispkg) #>                   objs <- rds[[name]] #>                   lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env,  #>                     filter = function(x) x %in% objs) #>                   break #>                 } #>                 else if (verbose)  #>                   message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\",  #>                     name, paste(names(rds), collapse = \",\")),  #>                     domain = NA) #>             } #>             if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) { #>                 warning(\"zipped data found for package \", sQuote(basename(dirname(p))),  #>                   \".\\nThat is defunct, so please re-install the package.\",  #>                   domain = NA) #>                 if (file_test(\"-f\", fp <- file.path(p, \"filelist\")))  #>                   files <- file.path(p, scan(fp, what = \"\", quiet = TRUE)) #>                 else { #>                   warning(gettextf(\"file 'filelist' is missing for directory %s\",  #>                     sQuote(p)), domain = NA) #>                   next #>                 } #>             } #>             else { #>                 files <- list.files(p, full.names = TRUE) #>             } #>             files <- files[grep(name, files, fixed = TRUE)] #>             if (length(files) > 1L) { #>                 o <- match(fileExt(files), dataExts, nomatch = 100L) #>                 paths0 <- dirname(files) #>                 paths0 <- factor(paths0, levels = unique(paths0)) #>                 files <- files[order(paths0, o)] #>             } #>             if (length(files)) { #>                 for (file in files) { #>                   if (verbose)  #>                     message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep,  #>                       basename(file), \"::\\t\", appendLF = FALSE,  #>                       domain = NA) #>                   ext <- fileExt(file) #>                   if (basename(file) != paste0(name, \".\", ext))  #>                     found <- FALSE #>                   else { #>                     found <- TRUE #>                     zfile <- file #>                     zipname <- file.path(dirname(file), \"Rdata.zip\") #>                     if (file.exists(zipname)) { #>                       Rdatadir <- tempfile(\"Rdata\") #>                       dir.create(Rdatadir, showWarnings = FALSE) #>                       topic <- basename(file) #>                       rc <- .External(C_unzip, zipname, topic,  #>                         Rdatadir, FALSE, TRUE, FALSE, FALSE) #>                       if (rc == 0L)  #>                         zfile <- file.path(Rdatadir, topic) #>                     } #>                     if (zfile != file)  #>                       on.exit(unlink(zfile)) #>                     switch(ext, R = , r = { #>                       library(\"utils\") #>                       sys.source(zfile, chdir = TRUE, envir = tmp_env) #>                     }, RData = , rdata = , rda = load(zfile,  #>                       envir = tmp_env), TXT = , txt = , tab = ,  #>                       tab.gz = , tab.bz2 = , tab.xz = , txt.gz = ,  #>                       txt.bz2 = , txt.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, as.is = FALSE), envir = tmp_env),  #>                       CSV = , csv = , csv.gz = , csv.bz2 = ,  #>                       csv.xz = assign(name, my_read_table(zfile,  #>                         header = TRUE, sep = \";\", as.is = FALSE),  #>                         envir = tmp_env), found <- FALSE) #>                   } #>                   if (found)  #>                     break #>                 } #>                 if (verbose)  #>                   message(if (!found)  #>                     \"*NOT* \", \"found\", domain = NA) #>             } #>             if (found)  #>                 break #>         } #>         if (!found) { #>             warning(gettextf(\"data set %s not found\", sQuote(name)),  #>                 domain = NA) #>         } #>         else if (!overwrite) { #>             for (o in ls(envir = tmp_env, all.names = TRUE)) { #>                 if (exists(o, envir = envir, inherits = FALSE))  #>                   warning(gettextf(\"an object named %s already exists and will not be overwritten\",  #>                     sQuote(o))) #>                 else assign(o, get(o, envir = tmp_env, inherits = FALSE),  #>                   envir = envir) #>             } #>             rm(tmp_env) #>         } #>     } #>     invisible(names) #> } #> <bytecode: 0x563a063d2ad8> #> <environment: namespace:utils> p <- weighted(data) #> Error in elev_change(data) %>% mutate(adjusted_wt = -elev_dif/1000 * 3.5) %>%     distinct(across(c(\"FIELD_ID\", \"station_id\")), .keep_all = TRUE): could not find function \"%>%\""}]
